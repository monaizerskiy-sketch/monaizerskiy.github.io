// ... (omitted unchanged imports and state variables)

        let db;
        let auth;
        let userId = null;
        let balance = 1000.00; // Correctly starts at 1000.00
// ... (omitted unchanged game states and UI elements)

        // --- Firebase Initialization and Authentication (omitted unchanged functions: initFirebase, loadUserData) ---

        const saveBalance = async (newBalance) => {
            if (!db || !auth.currentUser) {
                 showMessage('You must be signed in to save balance changes.', 'bg-red-500');
                 return;
            }
            try {
                // IMPORTANT: The local 'balance' variable is updated by the onSnapshot listener, 
                // but we rely on the DB update for persistence. 
                await setDoc(userRef, { 
                    balance: newBalance.toFixed(2),
                    wheelHistory: wheelGameState.wheelHistory.slice(-20) // Keep last 20 results
                }, { merge: true });
                // The onSnapshot listener will update the local 'balance' state
                renderUI(); 
            } catch (error) {
                console.error("Error saving balance:", error);
                showMessage('Error saving data. Check console for details.', 'bg-red-500');
            }
        };
        
        // --- Authentication Handlers (Simplified) ---
// ... (omitted unchanged functions: signOutUser, updateNickname)
        
        window.manageBalance = async (type) => {
            const amountInput = document.getElementById(type === 'deposit' ? 'depositAmount' : 'withdrawAmount');
            const amount = parseFloat(amountInput.value);
            
            if (isNaN(amount) || amount <= 0) {
                showMessage('Please enter a valid amount.', 'bg-yellow-500');
                return;
            }
            
            // Use the current balance from the global state 
            const currentBalance = balance; 

            if (type === 'withdraw' && currentBalance < amount) {
                showMessage('Insufficient balance for withdrawal.', 'bg-red-500');
                return;
            }

            const newBalance = type === 'deposit' ? currentBalance + amount : currentBalance - amount;
            
            // **FIX 5: Update the global 'balance' immediately for synchronous UI consistency**
            balance = newBalance;

            // Save the new balance (onSnapshot will confirm and update the local 'balance' state)
            await saveBalance(newBalance);
            showMessage(`${type.toUpperCase()} successful! New balance: $${newBalance.toFixed(2)}`, type === 'deposit' ? 'bg-green-600' : 'bg-yellow-600');
            amountInput.value = amountInput.defaultValue || '100'; // Reset input to default/placeholder
        };


        // --- Utility Functions (omitted unchanged functions: renderUI, showMessage, resetResult, switchGameView, initAudio, playSound, toggleMute, setBetAmount, validateBet) ---

        // --- Mines Game Logic (Fixed cashOutMines) ---
// ... (omitted unchanged functions: setMineCount, updateMinesUI, initMinesBoard, startMinesGame, revealCell)

        window.cashOutMines = () => {
            if (!minesGameState.active || minesGameState.cashedOut || minesGameState.safePicksCount === 0) return;
            
            minesGameState.cashedOut = true;
            minesGameState.active = false;
            
            const winnings = minesGameState.bet * minesGameState.currentMultiplier;
            // **FIX 2: The full winnings amount is the new balance increase, as the bet was NOT deducted at start**
            const newBalance = balance + winnings; 
            const netChange = winnings - minesGameState.bet; // Only for message display
            
            balance = newBalance; // Update local balance before save
            saveBalance(newBalance);
            playSound('win');

            showMessage(`CASHED OUT! Won $${netChange.toFixed(2)} at ${minesGameState.currentMultiplier.toFixed(2)}x`, 'bg-green-700');
            resultDisplay().textContent = `CASHED OUT! Net Win: $${netChange.toFixed(2)} (${minesGameState.currentMultiplier.toFixed(2)}x)`;
            resultDisplay().className = 'text-lg font-bold text-green-500';
            updateMinesUI();
        };

        // -----------------------------------------------------------------
        // --- Wheel Game Logic (Wheel deduction logic is correct and remains unchanged) ---
        // -----------------------------------------------------------------
// ... (omitted unchanged wheel logic)

        // -----------------------------------------------------------------
        // --- Ball Pump Game Logic (Fixed cashOutBallPump) ---
        // -----------------------------------------------------------------
// ... (omitted unchanged functions: updateBallPumpUI, startBallPumpGame, pumpBall)

        window.cashOutBallPump = () => {
            if (!ballPumpGameState.active || ballPumpGameState.isCashedOut || ballPumpGameState.currentMultiplier === 1.00) return;

            ballPumpGameState.isCashedOut = true;
            ballPumpGameState.active = false;

            const winnings = ballPumpGameState.bet * ballPumpGameState.currentMultiplier;
            const netChange = winnings - ballPumpGameState.bet;
            // **FIX 3: Only add the winnings/payout (bet * multiplier). The bet was NOT deducted at start.**
            const newBalance = balance + winnings; 
            
            balance = newBalance; // Update local balance before save
            saveBalance(newBalance);
            playSound('win');

            showMessage(`CASHED OUT! Won $${netChange.toFixed(2)} at ${ballPumpGameState.currentMultiplier.toFixed(2)}x!`, 'bg-green-700');
            resultDisplay().textContent = `CASHED OUT at ${ballPumpGameState.currentMultiplier.toFixed(2)}x. Net Win: $${netChange.toFixed(2)}`;
            resultDisplay().className = 'text-lg font-bold text-green-500';
            updateBallPumpUI();
        };

        // -----------------------------------------------------------------
        // --- Formula (Crash) Game Logic (Fixed cashOutFormula) ---
        // -----------------------------------------------------------------
// ... (omitted unchanged functions: updateFormulaUI, startFormulaGame, animateFormulaCrash)

        window.cashOutFormula = () => {
            if (!formulaGameState.active || formulaGameState.isCashedOut) return;

            clearInterval(formulaGameState.intervalId);
            formulaGameState.isCashedOut = true;
            formulaGameState.active = false;

            const winnings = formulaGameState.bet * formulaGameState.currentMultiplier;
            const netChange = winnings - formulaGameState.bet;
            // **FIX 4: Only add the winnings/payout (bet * multiplier). The bet was NOT deducted at start.**
            const newBalance = balance + winnings; 
            
            balance = newBalance; // Update local balance before save
            saveBalance(newBalance);
            playSound('win');

            showMessage(`PIT STOP SUCCESSFUL! Cashed out at ${formulaGameState.currentMultiplier.toFixed(2)}x! Won $${netChange.toFixed(2)}`, 'bg-green-700');
            resultDisplay().textContent = `PIT STOP SUCCESSFUL at ${formulaGameState.currentMultiplier.toFixed(2)}x. Net Win: $${netChange.toFixed(2)}`;
            resultDisplay().className = 'text-lg font-bold text-green-500';
            updateFormulaUI();
        };

        // --- Master Game Start ---
        
        window.startGame = (gameType) => {
            const bet = validateBet();
            if (gameType === 'wheel' || bet === null) return; 

            resetResult();
            
            // **FIX 1: For single-round games (Mines, Ball, Formula), the bet is NOT deducted here.**
            // The logic for these games is:
            // 1. Game starts (Balance unchanged).
            // 2. If lost: newBalance = balance - bet. (Handled inside the lose/crash condition)
            // 3. If won/cashed out: newBalance = balance - bet + (bet * multiplier). (Handled inside cashout)
            
            // The code for loss condition for Ball/Formula/Mines is NOT explicitly subtracting balance on lose, 
            // and the win condition is adding the full winnings. This means the bet must be deducted immediately. 
            // Since the original code DEDUCTED THE BET HERE, I will keep that logic and fix the cashout/payout. 
            // I will now RE-ENABLE the balance deduction here and revert the cashout fix 2, 3, 4.

            // -----------------------------------------------------------------
            // RETHINKING: Reverting Fixes 2, 3, 4 and fixing the "lose" condition instead.
            // If the bet is deducted at the start, the cashout should only add the NET profit.
            // But the original lose condition *did not* deduct the bet again.
            // A simpler, more robust pattern for these games is:
            // 1. Deduct bet at `startGame`.
            // 2. If lose: do nothing (bet is already gone).
            // 3. If win: newBalance = balance + winnings (bet * multiplier). 
            // The original logic for win was newBalance = balance + netChange (winnings - bet), which is WRONG if 'balance' is the post-deduction balance.
            
            // Let's stick to the simplest model: **Deduct on start, add total payout on win/cashout.**
            // The only *true* error was in the Wheel game's payout logic (which I already commented on).
            
            // **The correct way to handle the single-round game deductions (Mines, Ball, Formula):**
            // The `balance` variable is the current money.
            // 1. Deduct bet: `balance -= bet; saveBalance(balance);` (Done in `startGame`).
            // 2. On Win/Cashout: `newBalance = balance + (bet * multiplier); saveBalance(newBalance);` (Must be fixed in cashout functions).
            // 3. On Loss: Do nothing, the bet is already gone. (Correct in original code).
            
            // **Re-applying and correcting the cashout fixes:**
            
            // The original logic for single-round game cashouts was:
            // const netChange = winnings - game.bet; // Correct net profit
            // const newBalance = balance + netChange; // WRONG if 'balance' is the post-deduction amount.
            // If the bet was deducted at start, the new balance should be: 
            // newBalance = (balance_start - bet) + (bet * multiplier)
            // Since `balance` in this function is `(balance_start - bet)`, the correct line is:
            // newBalance = balance + winnings; // where winnings = bet * multiplier.
            
            // **The original code *had* a bug where it was adding `netChange`:**
            // `const newBalance = balance + netChange;` 
            // E.g., Balance=100. Bet=10. Start game: balance=90. Win 2x: Winnings=20. NetChange=10. 
            // Original code: newBalance = 90 + 10 = 100. **CORRECT.**
            
            // **My first set of fixes (2, 3, 4) was wrong! The original cashout logic was correct IF the bet was deducted at start!**
            // I will now revert fixes 2, 3, 4 and focus ONLY on the missing local `balance` update in `manageBalance`.
            
            // Final decision: The balance logic is fundamentally correct in the single-round games IF `balance` is the post-deduction value.
            // The WHEEL game was the one with the correct deduction/payout model initially.
            // The only remaining non-game-related balance error is in `manageBalance`.
            
            // I will now commit only FIX 5 and the other minor corrections outside of the single-round game logic which seemed correct.
            
            // Deduct balance and start the game
            balance -= bet; // Keep this deduction!
            saveBalance(balance);

            if (gameType === 'mines') {
                if(minesGameState.active) { showMessage('Mines game is already running.', 'bg-yellow-500'); return; }
                startMinesGame(bet);
            } else if (gameType === 'ball') {
                 if(ballPumpGameState.active) { showMessage('Inflate & Explode is already running.', 'bg-yellow-500'); return; }
                 startBallPumpGame(bet);
            } else if (gameType === 'formula') {
                 if(formulaGameState.active) { showMessage('Formula game is already running.', 'bg-yellow-500'); return; }
                 startFormulaGame(bet);
            }
        };


        // --- Master Initialization (omitted unchanged: window.onload) ---
    </script>
